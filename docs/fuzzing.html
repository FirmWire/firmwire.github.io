<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fuzzing - FirmWire</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">FirmWire</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="quick_start.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="background.html"><strong aria-hidden="true">3.</strong> Background</a></li><li class="chapter-item expanded "><a href="cli_reference.html"><strong aria-hidden="true">4.</strong> CLI Reference</a></li><li class="chapter-item expanded "><a href="workspaces.html"><strong aria-hidden="true">5.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="pattern_db.html"><strong aria-hidden="true">6.</strong> PatternDB</a></li><li class="chapter-item expanded "><a href="modkit.html"><strong aria-hidden="true">7.</strong> Baseband ModKit</a></li><li class="chapter-item expanded "><a href="interactive.html"><strong aria-hidden="true">8.</strong> Interactive exploration</a></li><li class="chapter-item expanded "><a href="fuzzing.html" class="active"><strong aria-hidden="true">9.</strong> Fuzzing</a></li><li class="chapter-item expanded "><a href="trophy_wall.html"><strong aria-hidden="true">10.</strong> Trophy Wall</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">FirmWire</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FirmWire/FirmWire/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fuzzing"><a class="header" href="#fuzzing">Fuzzing</a></h1>
<p>One of FirmWire's core contribution is the capability to fuzz the emulated baseband image using specialized fuzzing tasks.
These tasks are created using our <a href="modkit.html">modkit</a>, and use <a href="https://github.com/nccgroup/TriforceAFL">triforce-afl</a> hypercalls to communicate with the fuzzer, <a href="https://github.com/AFLplusplus/AFLplusplus">AFL++</a>.</p>
<p>This combination of injected tasks and hypercalls allows for transparent in-modem fuzzing: A fuzz task would get the input from the fuzzer and then send it as <em>message</em> to the targeted task. For the targeted task, the input received this way would look like benign input arriving over the usual channels. </p>
<p>FirmWire comes with some example fuzzing tasks, which were used in the evaluation of our <a href="../../firmwire-ndss22.pdf">paper</a>.
Let's look at one example task, to demonstrate how one would build a harness.</p>
<h2 id="example-harness-gsm-cc"><a class="header" href="#example-harness-gsm-cc">Example Harness: GSM CC</a></h2>
<p>Below is the high-level overview of our <a href="https://github.com/FirmWire/FirmWire/blob/main/modkit/shannon/fuzzers/gsm_cc.c">gsm_cc</a> harness for Shannon basebands:</p>
<pre><code class="language-C">#include &lt;shannon.h&gt;
#include &lt;afl.h&gt;

const char TASK_NAME[] = &quot;AFL_GSM_CC\0&quot;;

static uint32_t qid;

int fuzz_single_setup()
{
    ...
}
void fuzz_single()
{
    ...
}
</code></pre>
<p>First, <code>shannon.h</code> is included to provide shannon specific convenience functions (e.g. <code>uart_puts</code> and <code>pal_MemAlloc</code>).
Then, <code>afl.h</code> is included, which provides the main functionality and API for fuzzing. The API is a slightly modified version as the one given by TriforceAFL and provides following four functions:</p>
<table><thead><tr><th>Function</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>char * getWork(unsigned int *sizep)</code></td><td>Returns a buffer with fuzzing input and stores the input size into <code>sizep</code>.</td></tr>
<tr><td><code>int startWork(unsigned int start, unsigned int end)</code></td><td>Start a fuzzing execution, while collecting coverage for code residing between <code>start</code> and <code>end</code>.</td></tr>
<tr><td><code>int doneWork(int val)</code></td><td>Mark the end of a fuzzing iteration, providing <code>val</code> as return code to the fuzzer.</td></tr>
<tr><td><code>int startForkserver(int ticks)</code></td><td>Starts AFL forkserver. <code>ticks</code> controls whether qemu ticks should be enabled or not.</td></tr>
</tbody></table>
<p>Besides this API, the <code>afl.h</code>/<code>afl.c</code> files also provides the basic skeleton for the fuzzing loop inside a <code>task_main</code> function:</p>
<pre><code class="language-C">void task_main() {
    [...]
    if (!fuzz_single_setup()) {
      uart_puts(&quot;[!] Fuzzer init error\n&quot;);
      for (;;) ;
    }
    uart_puts(&quot;[+] Fuzzer init complete\n&quot;);

    uart_puts(&quot;[+] Starting fork server\n&quot;);
    startForkserver(1, AFL_PERSISTENT_LOOP_CTX);

    while (1) {
      fuzz_single();
    }
</code></pre>
<p>As we can see, this logic requires two additional functions: <code>fuzz_single_setup</code> and <code>fuzz_single</code>, which both need to be provided by our harness.
The first function is responsible for all task-specific setup. In the case of <code>gsm_cc</code>, this means (1) resolving the queueID for CC, (2) creating a <code>qitem_cc</code> memory chunk containing the correct msgGroup ID to initiate task initialization, and (3) sending the memory chunk as message to the according queue.</p>
<p>The full code for these three steps looks as below:</p>
<pre><code class="language-C">int fuzz_single_setup()
{
    qid = queuename2id(&quot;CC&quot;);

    struct qitem_cc * init = pal_MemAlloc(4, sizeof(struct qitem_cc), __FILE__, __LINE__);

    init-&gt;header.op = 0;
    init-&gt;header.size = 1;
    // 0x2a01 CC_INIT_REQ
    init-&gt;header.msgGroup = 0x2a01;
    pal_MsgSendTo(qid, init, 2);

    return 1;
}
</code></pre>
<p>When it comes to <code>fuzz_single</code>, this function is executed once per fuzzing iteration and is meant to forward the input from the fuzzer to the dedicated target task.</p>
<p>In case of <code>gsm_cc</code>, this includes the following steps:</p>
<ol>
<li>Create a memory chunk for the <code>qitem_cc</code> (just as above).</li>
<li>Get fuzzing input from the fuzzer using <code>getWork()</code>.</li>
<li>Validate that the input size is within valid boundaries.</li>
<li>Set up the <code>qitem_cc</code> to have the correct MessageGroup for RADIO_MSG types, as the contents for these are attacker controlled.</li>
<li>Moving the received input into <code>qitem_cc</code>.</li>
<li>Trigger the collection of coverage by calling <code>startWork</code>.</li>
<li>Sending the set up message to the target tasks. This will invoke the scheduler and the fuzztask is only scheduled back in after the message was processed.</li>
<li>Call <code>doneWork</code> to signalize the fuzzer that the input was processed, and the next iteration can start.</li>
</ol>
<p>In code, this looks as follows:</p>
<pre><code class="language-C">void fuzz_single()
{
    uint32_t input_size;
    uint16_t size;

    uart_puts(&quot;[+] Allocating Qitem\n&quot;);
    struct qitem_cc * item = pal_MemAlloc(4, sizeof(struct qitem_cc) + AFL_MAX_INPUT, __FILE__, __LINE__);

    if (!item) {
      uart_puts(&quot;ALLOC FAILED&quot;);
      return;
    }

    uart_puts(&quot;[+] Getting Work\n&quot;);
    char * buf = getWork(&amp;input_size);
    size = (uint16_t) input_size;
    // GSM radio messages are usually limited in size
    size = size &gt; 512 ? 512 : size;

    uart_puts(&quot;[+] Received n bytes: &quot;);
    uart_dump_hex((uint8_t *) &amp;size, 4); // Print some for testing

    if (size &lt; 3) {
      startWork(0, 0xffffffff); // memory range to collect coverage
      doneWork(0);
      return;
    }

    uart_puts(&quot;[+] Filling the qitem\n&quot;);
    item-&gt;header.op1 = 0xaa;
    item-&gt;header.op2 = 0x20;

    // Only target the RADIO_MSG msg types that get sent to the MM task
    item-&gt;header.msgGroup = 0x2a3c;

    item-&gt;header.size = size;

    memcpy(item-&gt;payload, buf, size);

    uart_puts(&quot;[+] FIRE\n&quot;);
    startWork(0, 0xffffffff); // memory range to collect coverage

    pal_MsgSendTo(qid, item, 2);
    doneWork(0);
}
</code></pre>
<p>Further examples on how to write fuzzing harnesses can be found by inspecting the source code of our other harnesses.
Our <a href="https://github.com/FirmWire/FirmWire/blob/main/modkit/shannon/fuzzers/lte_rrc.c">lte_rrc</a> fuzzer demonstrates for instance how a fuzzer would look like when the targeted task requires (a) an event to trigger message processing and (b) the input delivered in a separated memory chunk (rather than inlined in the qitem).</p>
<h2 id="controlling-the-fuzzing-process"><a class="header" href="#controlling-the-fuzzing-process">Controlling the fuzzing process</a></h2>
<p>Writing the fuzzing harness is only the first step; the second is to actually start the fuzzer.
FirmWire requires, at its minimum, two additional command line flags to facilitate fuzzing: <code>--fuzz</code> and <code>--fuzz-input</code>.
The first one will cause FirmWire to be started in fuzzing mode. This disables console output, debugging hooks, and similar to achieve maximum performance during fuzzing.
The latter flag advises FirmWire where it can find the current fuzzing input, and this is usually provided by AFL itself.
A full command line for starting fuzzing, on the example of <code>gsm_cc</code> would look like this:</p>
<pre><code>$ afl-fuzz -i in -o out -U -- ./firmwire.py --restore-snapshot fuzz_base --fuzz gsm_cc --fuzz-input @@ modem.bin
</code></pre>
<p>Assuming you have some seed inputs in the <code>in</code> directory, this command line should bring you directly to the AFL++ window.
Note how we used a snapshot here? As the boot time of the modem is quite long, AFL++ would timeout without these snapshot.
If you would like to fuzz without using the snapshot, we recommend to set the <code>AFL_FORKSRV_INIT_TMOUT</code> environment variable to a high value.</p>
<h2 id="persistent-mode"><a class="header" href="#persistent-mode">Persistent Mode</a></h2>
<p>Besides the <code>fuzz-mode</code>, FirmWire provides another option for further improving fuzzing throughput: persistent-mode fuzzing.
Instead of re-forking after every single fuzzing input, the emulator can process multiple inputs in a loop, re-forking only every N iterations.
From a programming perspective, this basically just means that <code>fuzz_single()</code> is invoked multiple times, and FirmWire keeps track of how many inputs were processed before issuing a new fork.</p>
<p>To use persistent mode, the command line only needs to be extended with <code>--fuzz-persistent N</code>. This means, when wanting to fuzz for 1000 iterations before re-forking, the command line above needs to be modified as follows:</p>
<pre><code>$ afl-fuzz -i in -o out -U -- ./firmwire.py --restore-snapshot fuzz_base --fuzz gsm_cc --fuzz-input @@ --fuzz-persistent 1000 modem.bin
</code></pre>
<p>To further improve persistent mode, we provide one additional feature: a persistent test case log.
Usually, upon crash, only the last input is saved by AFL++, as it assumes that the target state between two fuzz iterations did not change.
As baseband firmware is highly stateful, we cautiously violate this assumption during persistent fuzzing.</p>
<p>To not loose precious input during fuzzing which brings the baseband into different states, we also provide a <code>--fuzz-crashlog-dir</code> command line flag.
The argument to this flag should point to a directory. Upon crash, all inputs used in the according persistent iteration are stored into a file within this given directory.</p>
<h2 id="replaying-inputs"><a class="header" href="#replaying-inputs">Replaying Inputs</a></h2>
<p>During fuzzing, you may encounter some crashes or timeouts. But how to analyze them?</p>
<p>FirmWire brings a <code>--fuzz-triage</code> flag, which allows replaying of fuzzing inputs for a specific harness, while keeping logging output enabled.
The following command line will replay a test case called <code>crash.bin</code>, located in the same directory:</p>
<pre><code>$ ./firmwire.py --restore-snapshot fuzz_base --fuzz-triage gsm_cc --fuzz-input ./crash.bin modem.bin
</code></pre>
<p>Note that the fuzz-triage mode can also be coupled with different interactive capabilities (e.g., gdb) to facilitate root cause analysis.</p>
<p>Lastly, it is also possible to replay persistent crashlogs collected with <code>--fuzz-crashlog-dir</code>. This can be done by selecting the desired crashlog via <code>--fuzz-crashlog-replay</code>. </p>
<h3 id="happy-fuzzing"><a class="header" href="#happy-fuzzing">Happy Fuzzing!</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="interactive.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="trophy_wall.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="interactive.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="trophy_wall.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
